---
sidebar_position: 2
---

# Data Types

Data Types in Kvexium are a little "complicated" while giving you as a developer full control over the memory usage of your program.

## Boolean

### bool
The `bool` data type represents a boolean value, which can either be `true` or `false`.

**Example:**
```kvexium
dec isActive: bool := true;  // isActive is true
```

---

## String

### str
The `str` data type is an array of characters, representing textual data. - Psst. It's actually an array of char's like in C.

**Example:**
```kvexium
dec message: str := "Hello, Kvexium!";  // message holds a string
```

---

## Character

### char
The `char` data type represents a single character.

**Example:**
```kvexium
dec letter: char := 'A';  // letter holds a single character
```

---

## Integer Types

### i8, i16, i32, i64
These are signed integer types with varying bit lengths. They can hold both positive and negative decimal values.

**Example:**
```kvexium
dec a: i8 := -128;  // a is an 8-bit signed integer
dec b: i16 := 32767;  // b is a 16-bit signed integer
```

### u8, u16, u32, u64
These are unsigned integer types. They can only hold non-negative decimal values.

**Example:**
```kvexium
dec c: u8 := 255;  // c is an 8-bit unsigned integer
dec d: u32 := 4294967295;  // d is a 32-bit unsigned integer
```

---

## Floating Point Types

### f32, f64, f80
These represent floating-point numbers with single (32-bit), double (64-bit) and high (80-bit) precision, respectively.

**Example:**
```kvexium
dec pi: f32 := 3.14159F;  // pi is a 32-bit float
dec e: f64 := 2.718281828459F;  // e is a 64-bit float
dec n: f80 := 1.2345678901234567890123456789012345678901234567890F; // n is a 80-bit float
```

### v32, v64, v80
These represent unsigned floating-point numbers with single and double precision.

**Example:**
```kvexium
dec positiveValue: v32 := 4.5F;  // positiveValue is an unsigned 32-bit float
```

## Automatic Data Types

These Data Types will automaticly adjust themselfs to the smallest possible Data Type which can hold the given value - like in languages like C where it's `auto`.

### xtype
Represents every number, both signed and unsigned. It allows for a flexible definition of numeric variables.

**Example:**
```kvexium
dec x: xtype := 42;  // x can be any number
```

### ptype
Represents every unsigned number. This is useful for scenarios where negative values are not allowed.

**Example:**
```kvexium
dec y: ptype := 30;  // y can only be a positive number
```

### ftype
Represents every floating-point number. This includes both single and double precision floats.

**Example:**
```kvexium
dec z: ftype := 3.14F;  // z is a floating-point number
```

### vtype
Represents every unsigned floating-point number. This is helpful in mathematical computations that require non-negative values.

**Example:**
```kvexium
dec w: vtype := 2.718F;  // w is an unsigned float
```

### itype
Represents every non-decimal number. This is equivalent to integer types in other languages.

**Example:**
```kvexium
dec count: itype := 10;  // count is a non-decimal number
```

### utype
Represents every unsigned non-decimal number, ensuring only positive integers.

**Example:**
```kvexium
dec total: utype := 25;  // total is a positive integer
```
